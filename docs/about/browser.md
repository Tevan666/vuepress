---
sidebar: auto

---


# 浏览器原理与实践

## 网络

### IP

网际协议。**计算机的地址就称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。**如果要想把一个数据包从主机A发送给主机B，那么在传输之前，数据包上会被附加上主机B的IP地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机A本身的IP地址，有了这些信息主机B才可以回复信息给主机A。这些附加的信息会被装进一个叫IP头的数据结构里。IP头是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等信息。

**发送信息的过程**：

- 上层将含有信息的数据包交给网络层；
- 网络层再将IP头附加到数据包上，组成新的 **IP数据包**，并交给底层；
- 底层通过物理网络将数据包传输给主机B；
- 数据包被传输到主机B的网络层，在这里主机B拆开数据包的IP头信息，并将拆开来的数据部分交给上层；
- 最终，含有信息的数据包就到达了主机B的上层了。

### UDP

用户数据包协议(User Datagram Protocol)，用于分发数据给具体程序。

**IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序**。

**过程**：

- 上层将含有信息的数据包交给传输层；
- 传输层会在数据包前面附加上**UDP头**，组成新的UDP数据包，再将新的UDP数据包交给网络层；
- 网络层再将IP头附加到数据包上，组成新的IP数据包，并交给底层；
- 数据包被传输到主机B的网络层，在这里主机B拆开IP头信息，并将拆开来的数据部分交给传输层；
- 在传输层，数据包中的UDP头会被拆开，**并根据UDP中所提供的端口号，把数据部分交给上层的应用程序**；
- 最终，含有信息的数据包就旅行到了主机B上层应用程序这里。

**缺点：**

UDP可以检验数据是否正确，但不提供重发机制，直接丢弃，且无法知道是否能到达目的地。

**优点**：

传输速度快。

### TCP

完整地传达数据到应用程序。**TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议**。

**特点**:

- 对于数据包丢失的情况，TCP提供重传机制；
- TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
- 和UDP头一样，TCP头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

#### TCP三次握手

1. 第一次握手：`建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认`；SYN：同步序列编号（Synchronize Sequence Numbers）。
2. 第二次握手：`服务器收到syn包并确认客户的SYN`（ack=j+1），`同时也发送一个自己的SYN包`（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
3. 第三次握手：`客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）`，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

> 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

#### TCP 四次挥手

1. `客户端进程发出连接释放报文`，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，`客户端进入FIN-WAIT-1（终止等待1）状态`。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2）`服务器收到连接释放报文，发出确认报文`，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，`服务端就进入了CLOSE-WAIT（关闭等待）状态`。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3）客户端收到服务器的确认请求后，此时，`客户端就进入FIN-WAIT-2（终止等待2）状态`，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。

4）`服务器将最后的数据发送完毕后，就向客户端发送连接释放报文`，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，`服务器就进入了LAST-ACK（最后确认）状态`，等待客户端的确认。

5）`客户端收到服务器的连接释放报文后，必须发出确认`，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，`客户端就进入了TIME-WAIT（时间等待）状态`。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，`当客户端撤销相应的TCB后，才进入CLOSED状态`。

6）服务器只要收到了客户端发出的确认，`立即进入CLOSED状态`。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，`服务器结束TCP连接的时间要比客户端早一些`。

### 浏览器发起HTTP请求流程

#### 1.构建请求

#### 2.查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，**浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术**。

- 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
- 操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；
- 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
- ISP缓存：若上述均失败，继续向ISP搜索。

当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：

- 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
- 对于网站来说，缓存是实现快速资源加载的重要组成部分。

#### 3.DNS域名解析

​	浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。`DNS服务器是基于UDP的，因此会用到UDP协议`。

#### 4.建立TCP连接

​	解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接

#### 5.发起HTTP请求

​	浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器

#### 6.服务器响应请求并返回结果

​	服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器

#### 7.关闭TCP连接

​	通过四次挥手释放TCP连接

#### 8.浏览器渲染

​	客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：

- 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
- 构建CSS规则树：生成CSS规则树（CSS Rule Tree）
- 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
- 布局（Layout）：计算出每个节点在屏幕中的位置
- 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。

#### 9.JS引擎解析过程

调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

- 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。
- 加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译
- 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。
- 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。

