(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{385:function(_,v,t){"use strict";t.r(v);var a=t(28),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"浏览器原理与实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理与实践"}},[_._v("#")]),_._v(" 浏览器原理与实践")]),_._v(" "),t("h2",{attrs:{id:"网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[_._v("#")]),_._v(" 网络")]),_._v(" "),t("h3",{attrs:{id:"ip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip"}},[_._v("#")]),_._v(" IP")]),_._v(" "),t("p",[_._v("网际协议。**计算机的地址就称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。**如果要想把一个数据包从主机A发送给主机B，那么在传输之前，数据包上会被附加上主机B的IP地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机A本身的IP地址，有了这些信息主机B才可以回复信息给主机A。这些附加的信息会被装进一个叫IP头的数据结构里。IP头是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等信息。")]),_._v(" "),t("p",[t("strong",[_._v("发送信息的过程")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("上层将含有信息的数据包交给网络层；")]),_._v(" "),t("li",[_._v("网络层再将IP头附加到数据包上，组成新的 "),t("strong",[_._v("IP数据包")]),_._v("，并交给底层；")]),_._v(" "),t("li",[_._v("底层通过物理网络将数据包传输给主机B；")]),_._v(" "),t("li",[_._v("数据包被传输到主机B的网络层，在这里主机B拆开数据包的IP头信息，并将拆开来的数据部分交给上层；")]),_._v(" "),t("li",[_._v("最终，含有信息的数据包就到达了主机B的上层了。")])]),_._v(" "),t("h3",{attrs:{id:"udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[_._v("#")]),_._v(" UDP")]),_._v(" "),t("p",[_._v("用户数据包协议(User Datagram Protocol)，用于分发数据给具体程序。")]),_._v(" "),t("p",[t("strong",[_._v("IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("过程")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("上层将含有信息的数据包交给传输层；")]),_._v(" "),t("li",[_._v("传输层会在数据包前面附加上"),t("strong",[_._v("UDP头")]),_._v("，组成新的UDP数据包，再将新的UDP数据包交给网络层；")]),_._v(" "),t("li",[_._v("网络层再将IP头附加到数据包上，组成新的IP数据包，并交给底层；")]),_._v(" "),t("li",[_._v("数据包被传输到主机B的网络层，在这里主机B拆开IP头信息，并将拆开来的数据部分交给传输层；")]),_._v(" "),t("li",[_._v("在传输层，数据包中的UDP头会被拆开，"),t("strong",[_._v("并根据UDP中所提供的端口号，把数据部分交给上层的应用程序")]),_._v("；")]),_._v(" "),t("li",[_._v("最终，含有信息的数据包就旅行到了主机B上层应用程序这里。")])]),_._v(" "),t("p",[t("strong",[_._v("缺点：")])]),_._v(" "),t("p",[_._v("UDP可以检验数据是否正确，但不提供重发机制，直接丢弃，且无法知道是否能到达目的地。")]),_._v(" "),t("p",[t("strong",[_._v("优点")]),_._v("：")]),_._v(" "),t("p",[_._v("传输速度快。")]),_._v(" "),t("h3",{attrs:{id:"tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[_._v("#")]),_._v(" TCP")]),_._v(" "),t("p",[_._v("完整地传达数据到应用程序。"),t("strong",[_._v("TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("特点")]),_._v(":")]),_._v(" "),t("ul",[t("li",[_._v("对于数据包丢失的情况，TCP提供重传机制；")]),_._v(" "),t("li",[_._v("TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。")]),_._v(" "),t("li",[_._v("和UDP头一样，TCP头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。")])]),_._v(" "),t("h4",{attrs:{id:"tcp三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[_._v("#")]),_._v(" TCP三次握手")]),_._v(" "),t("ol",[t("li",[_._v("第一次握手："),t("code",[_._v("建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认")]),_._v("；SYN：同步序列编号（Synchronize Sequence Numbers）。")]),_._v(" "),t("li",[_._v("第二次握手："),t("code",[_._v("服务器收到syn包并确认客户的SYN")]),_._v("（ack=j+1），"),t("code",[_._v("同时也发送一个自己的SYN包")]),_._v("（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；")]),_._v(" "),t("li",[_._v("第三次握手："),t("code",[_._v("客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）")]),_._v("，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。")])]),_._v(" "),t("blockquote",[t("p",[_._v("握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。")])]),_._v(" "),t("h4",{attrs:{id:"tcp-四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手"}},[_._v("#")]),_._v(" TCP 四次挥手")]),_._v(" "),t("ol",[t("li",[t("code",[_._v("客户端进程发出连接释放报文")]),_._v("，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，"),t("code",[_._v("客户端进入FIN-WAIT-1（终止等待1）状态")]),_._v("。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。")])]),_._v(" "),t("p",[_._v("2）"),t("code",[_._v("服务器收到连接释放报文，发出确认报文")]),_._v("，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，"),t("code",[_._v("服务端就进入了CLOSE-WAIT（关闭等待）状态")]),_._v("。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。")]),_._v(" "),t("p",[_._v("3）客户端收到服务器的确认请求后，此时，"),t("code",[_._v("客户端就进入FIN-WAIT-2（终止等待2）状态")]),_._v("，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。")]),_._v(" "),t("p",[_._v("4）"),t("code",[_._v("服务器将最后的数据发送完毕后，就向客户端发送连接释放报文")]),_._v("，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，"),t("code",[_._v("服务器就进入了LAST-ACK（最后确认）状态")]),_._v("，等待客户端的确认。")]),_._v(" "),t("p",[_._v("5）"),t("code",[_._v("客户端收到服务器的连接释放报文后，必须发出确认")]),_._v("，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，"),t("code",[_._v("客户端就进入了TIME-WAIT（时间等待）状态")]),_._v("。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，"),t("code",[_._v("当客户端撤销相应的TCB后，才进入CLOSED状态")]),_._v("。")]),_._v(" "),t("p",[_._v("6）服务器只要收到了客户端发出的确认，"),t("code",[_._v("立即进入CLOSED状态")]),_._v("。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，"),t("code",[_._v("服务器结束TCP连接的时间要比客户端早一些")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"浏览器发起http请求流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器发起http请求流程"}},[_._v("#")]),_._v(" 浏览器发起HTTP请求流程")]),_._v(" "),t("h4",{attrs:{id:"_1-构建请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-构建请求"}},[_._v("#")]),_._v(" 1.构建请求")]),_._v(" "),t("h4",{attrs:{id:"_2-查找缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-查找缓存"}},[_._v("#")]),_._v(" 2.查找缓存")]),_._v(" "),t("p",[_._v("在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，"),t("strong",[_._v("浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术")]),_._v("。")]),_._v(" "),t("ul",[t("li",[_._v("浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；")]),_._v(" "),t("li",[_._v("操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；")]),_._v(" "),t("li",[_._v("路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；")]),_._v(" "),t("li",[_._v("ISP缓存：若上述均失败，继续向ISP搜索。")])]),_._v(" "),t("p",[_._v("当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：")]),_._v(" "),t("ul",[t("li",[_._v("缓解服务器端压力，提升性能（获取资源的耗时更短了）；")]),_._v(" "),t("li",[_._v("对于网站来说，缓存是实现快速资源加载的重要组成部分。")])]),_._v(" "),t("h4",{attrs:{id:"_3-dns域名解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-dns域名解析"}},[_._v("#")]),_._v(" 3.DNS域名解析")]),_._v(" "),t("p",[_._v("​\t浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。"),t("code",[_._v("DNS服务器是基于UDP的，因此会用到UDP协议")]),_._v("。")]),_._v(" "),t("h4",{attrs:{id:"_4-建立tcp连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-建立tcp连接"}},[_._v("#")]),_._v(" 4.建立TCP连接")]),_._v(" "),t("p",[_._v("​\t解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接")]),_._v(" "),t("h4",{attrs:{id:"_5-发起http请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-发起http请求"}},[_._v("#")]),_._v(" 5.发起HTTP请求")]),_._v(" "),t("p",[_._v("​\t浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器")]),_._v(" "),t("h4",{attrs:{id:"_6-服务器响应请求并返回结果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-服务器响应请求并返回结果"}},[_._v("#")]),_._v(" 6.服务器响应请求并返回结果")]),_._v(" "),t("p",[_._v("​\t服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器")]),_._v(" "),t("h4",{attrs:{id:"_7-关闭tcp连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-关闭tcp连接"}},[_._v("#")]),_._v(" 7.关闭TCP连接")]),_._v(" "),t("p",[_._v("​\t通过四次挥手释放TCP连接")]),_._v(" "),t("h4",{attrs:{id:"_8-浏览器渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-浏览器渲染"}},[_._v("#")]),_._v(" 8.浏览器渲染")]),_._v(" "),t("p",[_._v("​\t客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：")]),_._v(" "),t("ul",[t("li",[_._v("构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象")]),_._v(" "),t("li",[_._v("构建CSS规则树：生成CSS规则树（CSS Rule Tree）")]),_._v(" "),t("li",[_._v("构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）")]),_._v(" "),t("li",[_._v("布局（Layout）：计算出每个节点在屏幕中的位置")]),_._v(" "),t("li",[_._v("绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。")])]),_._v(" "),t("h4",{attrs:{id:"_9-js引擎解析过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-js引擎解析过程"}},[_._v("#")]),_._v(" 9.JS引擎解析过程")]),_._v(" "),t("p",[_._v("调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）")]),_._v(" "),t("ul",[t("li",[_._v("创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。")]),_._v(" "),t("li",[_._v("加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译")]),_._v(" "),t("li",[_._v("预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。")]),_._v(" "),t("li",[_._v("解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);